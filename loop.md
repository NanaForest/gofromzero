# Цикли

> Цикли це інструмент для виконання одного блоку коду декілька раз

Розглянемо найпростіший варіант цикла:
```golang
for i := 0; i < 10; i++ {
    fmt.Print(i, " ")
}
```
Програма виведе на екран: `0 1 2 3 4 5 6 7 8 9`

Розберемо в деталях компоненти цикла:
```
ДО ЦИКЛУ
for СТВОРИТИ СТАН; ПЕРЕВІРКА СТАНУ; ЗМІНА СТАНУ {
    ТІЛО ЦИКЛУ
}
ПІСЛЯ ЦИКЛУ
```

Ітерація - це виконання тілу цикла один раз

На початку цикла виконується блок "СТВОРИТИ СТАН", де ми можемо, хоча не забов'язані, створити нову змінну.
Наступний запис також буде правилним і за своїм результатом не буде відрізнятись від попереднього прикладу:
```
i := 0
for ; i < 10; i++ {
    fmt.Print(i, " ")
}
```

Однак невиличка різниця а даному коді все ж таки є. Щоб зрозуміти її, подивимось на наступні 2 приклади:
1:
```golang
for i := 0; i < 5; i++ {
    fmt.Print(i, " ")
}
fmt.Println(i)
```
2:
```golang
i := 0
for ; i < 5; i++ {
    fmt.Print(i, " ")
}
fmt.Println(i)
```

Приклад №1 не запуститься з помилкою про те, що на останній строчці змінної `i` не існує. Тобто, коли змінна створюється в блоці цикла "СТВОРИТИ СТАН", вона існує лише у межах цикла.

Блок "ЗМІНА СТАНУ" викликається кожен раз після виконання ТІЛА ЦИКЛУ і також не є обов'язковим
Наступний запис також буде правилним і за своїм результатом не буде відрізнятись від самого першого прикладу:
```golang
i := 0
for ; i < 10; {
    fmt.Print(i, " ")
    i++
}
```

Блок "ПЕРЕВІРКА СТАНУ" виконується одразу після блоку "ЗМІНА СТАНУ". Він також не є обов'язковим.
Запис нижче за своїм результатом не буде відрізнятись від інших прикладів:
```golang
i := 0
for {
    fmt.Print(i, " ")
    i++
    if i == 10 {
        break
    }
}
```
Ключове слово "break" використовується для припинення дії циклу. Тобто ми при пиняємо дію циклу, коли значення i дорівнює 10. break переміщую виконання програми на блок ПІСЛЯ ЦИКЛУ.
Але слід зауважити, що break запиную лише той цикл, в тілі котрого він написаний, тобто:
```golang
for i := 0; i < 3; i++ {
    fmt.Printf("i=%d ", i)
    for j := 0; j < 3; j++ {
        fmt.Printf("j=%d ", i)
        break
        fmt.Print("j:end")
    }
    fmt.Printf("i:end ", i)
    fmt.Println()
}
```
Результатом данної програми буде:
```
i=0 j:0 i:end
i=1 j:0 i:end
i=2 j:0 i:end
```
Внутрішній цикл ніколи не перейде на другу ітерацію (там де j=1), томущо break буде виконаний безумовно, тобто на першій ітерації.

В блоці ПЕРЕВІРКА СТАНУ може бути будь який вираз або змінна булевого типу:
```golang
b := true
for i := 0; b; i++  {
    if i >= 5 {
        b = false
    }
}
```
В прикладі вище, на шостій ітерації, коли `i` стане дорівнювати 5, виконається умова і змінній `b` буде присвоєно значення false. Оскільки `b` використовується як єдина умова в блоці цикла ПЕРЕВІРКА СТАНУ, то після цієї шостої ітерації цикл завершиться.

Є ще одне ключове слово для роботи з циклами:
```golang
for i := 0; i <= 5; i++ {
    if i % 2 == 0 {
        continue
    }
    fmt.Print(i, " ")
}
```
Результат буде наступний: `1 3 5`

Ключове слово `continue` виконує роль зупинення **поточної** ітерації цикла з подальшим виконанням блоку ЗМІНА СТАНУ і переносом на наступну ітерацію

Але варто бути обережним, наприклад наступний код ніколи не завершиться:
```golang
i := 0
for ; i <= 5; {
    if i % 2 == 0 {
        continue
    }
    fmt.Print(i, " ")
}
```
В цьому прикладі на першій ітерації буде виконана умова `i % 2 == 0`, тобто `0 % 2 == 0`, але оскільки наш блок ЗМІНА СТАНУ залишився пустим, то `і` назавжди залишиться нулем і, відповідно, умова закінчення циклу ніколи не виконається.
