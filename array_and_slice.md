
# Масиви

> Масив - складений тип даних, послідовність елементів однакового типу з фіксованою довжиною

## Створення масиву

Форма запису створення масива:
```golang
arr := [3]int{}
```

Код вище створить масив довжиною 3, що означає що в пам'яті буде виділено місце рівно під 3 елементи типу `int`

> Зверни увагу, що встановлення довжини масива є необхідною умовою, і його довжина не може бути змінена на протязі життя всієї програми

Якщо вивести на екран даний масив, не дивлячись на то, що ми не задали жодного значення, ми отримаємо: `[0, 0, 0]`

Це відбувається за рахунок того, що масив має фіксовану довжину, в нашому прикладі це **3 елементи типу int** (`[3]int`). Тобто в момент створення масив в пам'яті буде виділено місце умовно наступним чином:
```
00000000 00000000 00000000
```
Тобто це 3 незаповнених елементи типу `int`, а незаповнений елемент типу `int` трактується як нуль

Тобто два наступних записи є еквівалентними:
```golang
arr1 := [3]int{}
arr2 := [3]int{0,0,0}
```

Але, якщо ми запишемо
```golang
arr := [3]int{1}
```
буде створений масив `[1, 0, 0]`

## Доступ до  елементів масива

Доступ до елементів масив відбувається по індексу.

Індекс:
- це порядковий номер елементу масива
- завжди є цілим числом
- завжди починається з нуля

Припустимо ми маємо масив:
```golang
arr := [3]rune['a', 'b', 'c']
```
Щоб отримати другий елемент цього масива ми маємо записати:
```golang
second := arr[1]
```
Команда вище створить нову змінну під назвою `second`, що буде мати тип `rune` і значення `'b'`

> Зверни увагу, що змінна `second` і масив `arr` ніяк не пов'язані, змінна `arr` має свою область в пам'яті, змінна `second` - свою. Тобто якщо ми пізніше в програмі змінемо `arr[1]`, це ніяк не вплине на змінну `second`

Відповідно, щоб змінити певний елемент масиву, ми маємо записати:
```golang
arr[1] = 'X'
```

Ми також можемо змінювати елемент через використовуючі іншу змінну в якості індекса:
```golang
i := 1
arr[i] = 'O'
```

> Зверни увагу, що по аналогії з прикладом зі змінною `second`, якщо змінна `i` буде змінена після зміни елемента масива, це ніяк не вплине не масив, тобто в наступному записі масив буде змінений лишен один раз:
```golang
i := 1
arr[i] = 'O'
i = 2
```

Приклад того, як ми можемо поміняти елементи масиву місцями:
```golang
arr := [2]int{1, 2}
arr[1], arr[0] = arr[0], arr[1]
```
Якщо записати як виконується програма вище послідовно, отримаємо наступне:
```
1. arr[1], arr[0] = 1, 2
2. arr[1] = 1
3. arr[0] = 2
4. fmt.Println(arr) // отримаємо '[2, 1]'
```

Щоб дізнатися довжину масива ми можемо використати функцію `len`:
```golang
arr := [3]string{"a", "b", "c"}
fmt.Println(len(arr)) // отримаємо: 3
```

Щоб отримати доступ до останнього елементу масиву, ми можемо записати наступне:
```golang
arr := [3]string{"a", "b", "c"}
fmt.Println(arr[len-1]) // отримаємо "c"
```

Спроба дістати елемент по індекс, що не існує викличе у програми паніку:
```golang
arr := [3]string{"a", "b", "c"}
a := arr[3] // panic!!! - програма зупиниться тут
b := arr[2]
```

# Слайси

> Слайс не є окремим типом даних, він лише виконує функцію "обгортки" над масивом, що означає, що коли ми створюємо слайс, то слайс не працює з пам'ятью самостійно, він спирається на масив, іншими словами слайс "під капотом" створює масив. Коли ми записуємо значення в слайс, він записує значення в масив. Коли ми читаємо значення зі слайса, він повертає нам те, що знаходиться в масиві.

Особливістю слайса є те, що він не має фіксованої довжини. В реальному житті ми майже ніколи не знаємо яка довжина масива нам потрібна зазадалегіть, тому масиви використовуються дуже рідко.

Є дві форми створення слайса:
```golang
// перша
slc1 := []int{1, 2, 3}
// друга
slc2 := make([]int, 3, 6)
```

Розберемо першу форму. Вона схожа на те, як ми створюємо масив:
```golang
arr := [3]int{1, 2, 3} // масив
slc := []int{1, 2, 3} // слайс
```
Різниця лише в тому, що для слайса ми не вказуємо довжину. Це лише ще раз вказує на те, що слайс не має фіксованої довжини.
В цьому варіанті створення слайса, під капотом буде створений масив довжиною 3. Якщо ми виведемо цей слайс на екран, ми отримаємо: `[1, 2, 3]`

Порівняємо з масивом:
```golang
arr := [2]int{} // [0, 0]
slc := []int{} // []
```
При даній формі запису, за замовчуванням слайс створить собі масив нульової довжини.

Розглянемо іншу (більш використовувану) форму створення слайса:
```golang
slc1 := make([]int, 3, 6)
fmt.Println(slc1) // [0, 0, 0]
```
В даному прикладі, коли ми створюємо слайс ми визначаємо його довжину 3, саме через це на відміну від першої форми створення слайсу, якщо ми виведемо його  на екран ми побачимо 3 елементи.

Ми можемо отримати поточну довжину слайс за допомогою тієї самої функції `len`:
```golang
slc1 := make([]int, 3, 6)
fmt.Println(len(scl1)) // виведе: 3
```

Але, як ти могла помітити, на відміну від першої форми створення слайсу, ми також вказуємо інше число, у прикладі вище це 6.

Це число являє собою **capacity**, тобто "ємність" слайсу. Ємність це ніщо інакше як довжина масива який буде створений під капотом. 
Go має окрему функцію, котра дозволяє подивитись значення ємності у слайса (тобто довжину масива, котрим оперує слайс під капотом):
```golang
slc1 := make([]int, 3, 6)
fmt.Println(cap(slc1)) // виведе: 6
```

Варто зазначити, що ємнісь не може бути менше ніж довжина слайса:
```golang
slc := make([]int, 3, 2) // така програма не буде працювати
```

Також нам не обов'язково вказувати ємність, за замовчуванням вона буде дорівнювати довжині самого слайса:
```golang
slc1 := make([]int, 3)
fmt.Println(cap(slc1)) // виведе: 3
```

Розберемось в суті слайса, тобто в тому як він влаштований.

Для початку познайомимось з функцією додавання елементів в кінець слайса:
```golang
slc1 := []int{1, 2, 3}
fmt.Println(slc1) // виведе: [1, 2, 3]
fmt.Println(len(slc1), cap(slc1)) // виведе: 3, 3
slc1 = append(slc1, 4, 5, 6)
fmt.Println(slc1) // виведе: [1, 2, 3, 4, 5, 6]
fmt.Println(len(slc1), cap(slc1)) // виведе: 6, 6
```

Розберемо цей приклад в деталях:
1. ми створили слайс `[]int{1, 2, 3}` - його довжина на ємність дорівнює 3
2. ми додаємо 3 інших елемент в слайс - так як ємність дорівнює 3, ці елементи не можуть бути додані в існуючий масив. Тому, щоб задовольнити бажану зміну, слайс створить новий масив довжиною 6, потім скопіює зі старого масива існуючі елементи в новий, а також додасть 3 нових елементи в новоутворений масив. Старий же масив буде видалений, оскільки він більше не потрібен.

Як видно, слайс робить деяку роботу за нас, в цьому його цінність.

Розглянемо схожий приклад:
```golang
slc1 := make([]int, 3, 6)
fmt.Println(slc1) // виведе: [0, 0, 0]
slc1[0], slc1[1], slc1[2] = 1, 2, 3
fmt.Println(slc1) // виведе: [1, 2, 3]
fmt.Println(len(slc1), cap(slc1)) // виведе: 3, 6
slc1 = append(slc1, 4, 5, 6)
fmt.Println(slc1) // виведе: [1, 2, 3, 4, 5, 6]
fmt.Println(len(slc1), cap(slc1)) // виведе: 6, 6
```

В чому відмінність? Розберемо в деталях:
1. на перших чотирьох строчках ми створили слайс з довжиною 3 та ємністю 6. 
2. на наступній строчці ми модифікуємо існуючий слайс, ми присвоюємо значення 1, 2, 3 в елменти під індексами 0, 1, 2 відповідно
3. далі ми додаємо 3 нових елементи в слайс, результатом буде слайс `[1, 2, 3, 4, 5, 6]`, відповідно довжина зміненого слайса буде 6.
Відмінність цього прикладу заключається в тому, що коли ми намагаємось додавати елементи в кінець слайса, то масив, котрим слайс оперує, має достатню довжину (6), щоб задовольнити ці зміни, тобто додати 3 нови елементи. Це означає, що слайсу не потрібно створювати новий масив під капотом.
З цього ми можемо зробити висновок, що майже завжди має сенс давати слайсу capacity c запасом, щоб не змушувати його робити додаткові дії.

Розглянемо ще один приклад:
```golang
slc := make([]int, 0, 5)
fmt.Println(slc, len(slc), cap(slc))
slc = append(slc, 1)
fmt.Println(slc, len(slc), cap(slc))
slc = append(slc, 2)
fmt.Println(slc, len(slc), cap(slc))
slc = append(slc, 3)
fmt.Println(slc, len(slc), cap(slc))
slc = append(slc, 4)
fmt.Println(slc, len(slc), cap(slc))
slc = append(slc, 5)
fmt.Println(slc, len(slc), cap(slc))
slc = append(slc, 6)
fmt.Println(slc, len(slc), cap(slc))
```
Вивід буде наступний:
```
[] 0 5
[1] 1 5
[1 2] 2 5
[1 2 3] 3 5
[1 2 3 4] 4 5
[1 2 3 4 5] 5 5
[1 2 3 4 5 6] 6 10
```
На останньому прикладі можно помітити як слайс збільшив свій масив вдвічі.

Важливо розуміти, що не дивлячись на те, що слайс може мати велику ємність, ми можемо присвоювати та отримувати значення лише в межах поточної довжини слайсу.
```golang
slc := make([]int, 2, 10)
fmt.Println(slc[0]) // 0
fmt.Println(slc[1]) // 0
fmt.Println(slc[2]) // panic! - останній індекс одиниця
```

Слід також зауважити, що коли ми створюємо один слайс з іншого, його значення не копіюються, а копіюється посилання на масив, що знаходиться під капотом слайса:
```golang
slc1 := []int{1, 2, 3}
slc2 := slc1
fmt.Println(slc1) // [1, 2, 3]
slc2[0] = 10
fmt.Println(slc1) // [10, 2, 3]
slc1[1] = 20
fmt.Println(slc2) // [10, 20, 3]
```
З прикладу вище видно, що зміна елементів одного слайса призводить до зміни елементів іншого. Це пояснюється тим, що  вони під капотом використовують один і той самий масив. 

> Для розуміння з зірочкою: якщо один із слайсів буде змушений під капотом створити новий масив (дивись пояснення вище), з того моменту їхні масиви будуть різні і відповідно зміна елементів одно слайса не призведе до зміни елементів іншого:
```golang
slc1 := []int{1, 2, 3}
slc2 := slc1
slc1 = append(slc1, 4, 5, 6) // на цьому етапі slc1 під капотом створить новий масив, бо поточному масиву не вистачає довжини, щоб додати нові елементи
fmt.Println(slc1) // [1, 2, 3, 4, 5, 6]
fmt.Println(slc2) // [1, 2, 3]
slc2[0] = 10
fmt.Println(slc1) // [1, 2, 3, 4, 5, 6]
fmt.Println(slc2) // [10, 2, 3]
```

## Ітерація по слайсу

> Ітерація - можливість виконати один блок кода для кожного елемента масиву/слайса.

Ми вже знаємо, що перший індекс буде дорівнювати нулю. Ми також знаємо як знайти кількість елементів в слайсі.
Таким чином знаючи перший та останній індекс, ми можемо дізнатися номера всіх індексів.

Розберемо наступний приклад:
```golang
slc := make([]int, 3)
for i := 0; i < len(slc); i++ {
    fmt.Println("index = ", i, ", value = ", slc[i])
}
```
Результатом виконання буде наступний вивід в консоль:
```
index = 0, value = 0
index = 1, value = 0
index = 2, value = 0
```

Приклад генерації рандомного слайса числами від 0 до 10:
```golang
slc := make([]int, 10)
for i := 0; i < len(slc); i++ {
    slc[i] = rand.IntN(10)
}
```


## Матриці

Елементами слайсів також можуть виступати інші слайси, це можна називати матрицею (від математичної матриці), або двовимірним слайсом:
```golang
slc := [][]int{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
}
```

Цей запис буде ідентичним до:
```golang
slc1 := []int{1, 2, 3}
slc2 := []int{4, 5, 6}
slc3 := []int{7, 8, 9}
slc := [][]int{slc1, slc2, slc3}
```

Доступ до елементів такого слайса виконується звичайним чином:
```golang
slc := [][]int{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
}

slc1 := slc[0]
fmt.Println(slc1) // [1, 2, 3]

slc2 := slc[1]
fmt.Println(slc2) // [4, 5, 6]

slc3 := slc[2]
fmt.Println(slc3) // [7, 8, 9]
```

Можемо також отримати певний елемент:
```golang
slc := [][]int{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
}
fmt.Println(slc[0][1]) // 2
fmt.Println(slc[1][1]) // 5
fmt.Println(slc[2][1]) // 8
```

Для ітерації по двовимірному слайсу:
```golang
slc := [][]int{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
}
for i := 0; i < len(slc); i++ { // індекс для двовимірного слайса
    for j := 0; j < len(slc[i]); i++ { // індекс для елемента двовимірного слайса
        fmt.Println(slc[i][j])
    }
    fmt.Println() // виводимо нову строку після того, як вивели всі елементи одного слайса
}
```
Результатом має бути:
```
123
456
789
```
