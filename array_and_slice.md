
# Масиви

> Масив - складений тип даних, послідовність елементів однакового типу з фіксованою довжиною

## Створення масиву

Форма запису створення масива:
```golang
arr := [3]int{}
```

Код вище створить масив довжиною 3, що означає що в пам'яті буде виділено місце рівно під 3 елементи типу `int`

> Зверни увагу, що встановлення довжини масива є необхідною умовою, і його довжина не може бути змінена на протязі життя всієї програми

Якщо вивести на екран даний масив, не дивлячись на то, що ми не задали жодного значення, ми отримаємо: `[0, 0, 0]`

Це відбувається за рахунок того, що масив має фіксовану довжину, в нашому прикладі це **3 елементи типу int** (`[3]int`). Тобто в момент створення масив в пам'яті буде виділено місце умовно наступним чином:
```
00000000 00000000 00000000
```
Тобто це 3 незаповнених елементи типу `int`, а незаповнений елемент типу `int` трактується як нуль

Тобто два наступних записи є еквівалентними:
```golang
arr1 := [3]int{}
arr2 := [3]int{0,0,0}
```

Але, якщо ми запишемо
```golang
arr := [3]int{1}
```
буде створений масив `[1, 0, 0]`

## Доступ до  елементів масива

Доступ до елементів масив відбувається по індексу.

Індекс:
- це порядковий номер елементу масива
- завжди є цілим числом
- завжди починається з нуля

Припустимо ми маємо масив:
```golang
arr := [3]rune['a', 'b', 'c']
```
Щоб отримати другий елемент цього масива ми маємо записати:
```golang
second := arr[1]
```
Команда вище створить нову змінну під назвою `second`, що буде мати тип `rune` і значення `'b'`

> Зверни увагу, що змінна `second` і масив `arr` ніяк не пов'язані, змінна `arr` має свою область в пам'яті, змінна `second` - свою. Тобто якщо ми пізніше в програмі змінемо `arr[1]`, це ніяк не вплине на змінну `second`

Відповідно, щоб змінити певний елемент масиву, ми маємо записати:
```golang
arr[1] = 'X'
```

Ми також можемо змінювати елемент через використовуючі іншу змінну в якості індекса:
```golang
i := 1
arr[i] = 'O'
```

> Зверни увагу, що по аналогії з прикладом зі змінною `second`, якщо змінна `i` буде змінена після зміни елемента масива, це ніяк не вплине не масив, тобто в наступному записі масив буде змінений лишен один раз:
```golang
i := 1
arr[i] = 'O'
i = 2
```

Приклад того, як ми можемо поміняти елементи масиву місцями:
```golang
arr := [2]int{1, 2}
arr[1], arr[0] = arr[0], arr[1]
```
Якщо записати як виконується програма вище послідовно, отримаємо наступне:
```
1. arr[1], arr[0] = 1, 2
2. arr[1] = 1
3. arr[0] = 2
4. fmt.Println(arr) // отримаємо '[2, 1]'
```

Щоб дізнатися довжину масива ми можемо використати функцію `len`:
```golang
arr := [3]string{"a", "b", "c"}
fmt.Println(arr) // отримаємо: 3
```

Щоб отримати доступ до останнього елементу масиву, ми можемо записати наступне:
```golang
arr := [3]string{"a", "b", "c"}
fmt.Println(arr[len-1]) // отримаємо "c"
```

Спроба дістати елемент по індекс, що не існує викличе у програми паніку:
```golang
arr := [3]string{"a", "b", "c"}
a := arr[3] // panic!!! - програма зупиниться тут
b := arr[2]
```

# Слайси

> Слайс не є окремим типом даних, він лише виконує функцію "обгортки" над масивом, що означає, що коли ми створюємо слайс, то слайс "під капотом" створює масив. Коли ми записуємо значення в слайс, він записує значення в масив. Коли ми читаємо значення зі слайса, він повертає нам те, що знаходиться в масиві.

Особливістю слайса є те, що він не має фіксованої довжини. В реальному житті ми майже ніколи не знаємо яка довжина масива нам потрібна зазадалегіть, тому масиви використовуються дуже рідко.

Є дві форми створення слайса:
```golang
// перша
slc1 := []int{1, 2, 3}
// друга
slc2 := make([]int, 3, 6)
```

Розберемо першу форму. Вона схожа на те, як ми створюємо масив, за виключенням того, що ми не вказуємо довжину. Це є логічним, оскільки як сказано раніше, слайс не має фіксованої довжини.
В цьому варіанті створення слайса, під капотом буде створений масив довжиною 3. Якщо ми виведемо цей масив на екран, ми отримаємо: `[1, 2, 3]`

Давай також спробуємо створити слайс без значень:
```golang
slc1 := []int{}
```
Якщо ми спробуємо вивести його на екран, то побачимо `[]`, що означатиме, що під капотом був створений масив нульової довжини.

Розглянемо іншу (більш використовувану) форму створення слайса:
```golang
slc1 := make([]int, 3, 6)
```
Почнемо з того, що якщо ми виведемо створений слайс на екран, ми отримаємо `[0, 0, 0]` - тобто 3 в цьому випадку буде означати "довжину" слайса, котру ми отримаємо якщо викличемо функцію `len`:
```golang
slc1 := make([]int, 3, 6)
fmt.Println(len(scl1)) // виведе: 3
```
Але, на відміну від першої формі запису створення слайсу, ти помітила, що ми також можемо вказати інше число, у нашому випадку це 6.

Це число являє собою **capacity**, тобто "ємність" слайсу. Ємність визначає масив якої довжини буде створений під капотом. Go має окрему функція, котра дозволяє подивитись значення ємності у слайса:
```golang
slc1 := make([]int, 3, 6)
fmt.Println(cap(slc1)) // виведе: 6
```

Варто зазначити, що ємнісь не може буде менше ніж довжина слайса, а також нам не обов'язково вказувати ємність, за замовчуванням вона буде дорівнювати довжині:
```golang
slc1 := make([]int, 3)
fmt.Println(cap(slc1)) // виведе: 3
```

Розберемось в суті слайса та його ємності.

Для початку познайомимось з функцією додавання елементів в кінець слайса:
```golang
slc1 := []int{1, 2, 3}
fmt.Println(slc1) // виведе: [1, 2, 3]
fmt.Println(len(slc1), cap(slc1)) // виведе: 3, 3
slc1 = append(slc1, 4, 5, 6)
fmt.Println(slc1) // виведе: [1, 2, 3, 4, 5, 6]
fmt.Println(len(slc1), cap(slc1)) // виведе: 6, 6
```

Розберемо цей приклад в деталях:
1. ми створили слайс `[]int{1, 2, 3}` - його довжина на ємність дорівнює 3
2. ми додаємо 3 інших елемент в слайс - так як ємність (а тобто довжина масива, що знаходиться під капотом слайса) дорівнює 3, ці елементи не можуть бути додані в існуючий масив. Тому, щоб задовольнити бажану зміну, слайс створить новий масив довжиною 6, потім скопіює зі старого масива існуючі елементи в новий, а також додасть 3 нових елементи в новоутворений масив. Старий же масив буде видалений.

Як видно, слайс робить деяку роботу за нас, в цьому його цінність.

Розглянемо подібний приклад:
```golang
slc1 := make([]int, 3, 6)
fmt.Println(slc1) // виведе: [0, 0, 0]
slc1[0], slc1[1], slc1[2] = 1, 2, 3
fmt.Println(slc1) // виведе: [1, 2, 3]
fmt.Println(len(slc1), cap(slc1)) // виведе: 3, 6
slc1 = append(slc1, 4, 5, 6)
fmt.Println(slc1) // виведе: [1, 2, 3, 4, 5, 6]
fmt.Println(len(slc1), cap(slc1)) // виведе: 6, 6
```

В чому відмінність? Розберемо в деталях:
1. на перших чотирьох строчках ми створили слайс з довжиною 3 та ємністю 6. 
2. на наступній строчці ми модифікуємо існуючий слайс, ми присвоюємо значення 1, 2, 3 в елменти під індексами 0, 1, 2 відповідно
3. далі ми додаємо 3 нових елементи в слайс, зауважимо, що при створенні слайса ми визначили його довжину як 3, з чого слідує, що функція додавання елементів в кінець слайса (`append`) додасть 4, 5 та 6 елементи. Після її виконання довжина слайса буде 6. 
Відмінність цього прикладу заключається в тому, що коли ми намагаємось додавати елементи в кінець слайса, масив, котрим слайс оперує, має достатню довжину (6), що задовольнити ці зміни, тобто додати 3 нови елементи. Це означає, що слайсу не потрібно створювати новий масив під капотом.
З цього ми можемо зробити висновок, що майже завжди має сенс давати слайсу capacity c запасом, щоб не змушувати його робити додаткові дії.

Налогосимо ще раз:
- для присвоєння значення елементу слайсу ми використовуємо такий самий запис присвоєння по індексу як ми це робимо з масивом: `slc[1] = 10`
- для розширення довжини слайса ми використовуємо функцію `append`: 
```golang
slc := make([]int, 0, 10)
fmt.Println(len(slc), cap(slc)) // 0, 10
slc = append(slc, 1)
slc = append(slc, 2)
slc = append(slc, 3)
slc = append(slc, 4)
fmt.Println(slc) // [1, 2, 3, 4]
fmt.Println(len(slc), cap(slc)) // 4, 10
```

Важливо розуміти, що не дивлячись на те, що слайс може мати велику ємність, ми можемо присвоювати та отримувати значення лише в межах довжини слайсу.
```golang
slc := make([]int, 2, 10)
fmt.Println(slc[0]) // 0
fmt.Println(slc[1]) // 0
fmt.Println(slc[2]) // panic! - останній індекс одиниця
```

Слід також зауважити, що коли ми створюємо один слайс з іншого, його значення не копіюються, а копіюється посилання на масив, що знаходиться під капотом слайса:
```golang
slc1 := []int{1, 2, 3}
slc2 := slc1
fmt.Println(slc1) // [1, 2, 3]
slc2[0] = 10
fmt.Println(slc1) // [10, 2, 3]
slc1[1] = 20
fmt.Println(slc2) // [10, 20, 3]
```
З прикладу вище видно, що зміна елементів одного слайса призводить до зміни елементів іншого. Це пояснюється тим, що  вони під капотом використовують один і той самий масив. 

> Для розуміння з зірочкою: якщо один із слайсів буде змушений під капотом створити новий масив (дивись пояснення вище), з того моменту їхні масиви будуть різні і відповідно зміна елементів одно слайса не призведе до зміни елементів іншого:
```golang
slc1 := []int{1, 2, 3}
slc2 := slc1
slc1 = append(slc1, 4, 5, 6) // на цьому етапі slc1 під капотом створить новий масив, бо поточному масиву не вистачає довжини, щоб додати нові елементи
fmt.Println(slc1) // [1, 2, 3, 4, 5, 6]
fmt.Println(slc2) // [1, 2, 3]
slc2[0] = 10
fmt.Println(slc1) // [1, 2, 3, 4, 5, 6]
fmt.Println(slc2) // [10, 2, 3]
```

## Ітерація по слайсу

> Ітерація - можливість виконати один блок кода для кожного елемента масиву/слайса.

Ми вже знаємо, що перший індекс буде дорівнювати нулю. Ми також знаємо як знайти кількість елементів в слайсі.
Таким чином знаючи перший та останній індекс, ми можемо дізнатися номера всіх індексів.

Розберемо наступний приклад:
```golang
slc := make([]int, 3)
for i := 0; i < len(slc); i++ {
    fmt.Println("index = ", i, ", value = ", slc[i])
}
```
Результатом виконання буде наступний вивід в консоль:
```
index = 0, value = 0
index = 1, value = 0
index = 2, value = 0
```

Приклад генерації рандомного слайса числами від 0 до 10:
```golang
slc := make([]int, 10)
for i := 0; i < len(slc); i++ {
    slc[i] = rand.IntN(10)
}
```


## Матриці

Елементами слайсів також можуть виступати інші слайси, це можна називати матрицею (від математичної матриці), або двовимірним слайсом:
```golang
slc := [][]int{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
}
```

Цей запис буде ідентичним до:
```golang
slc1 := []int{1, 2, 3}
slc2 := []int{4, 5, 6}
slc3 := []int{7, 8, 9}
slc := [][]int{slc1, slc2, slc3}
```

Доступ до елементів такого слайса виконується звичайним чином:
```golang
slc := [][]int{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
}

slc1 := slc[0]
fmt.Println(slc1) // [1, 2, 3]

slc2 := slc[1]
fmt.Println(slc2) // [4, 5, 6]

slc3 := slc[2]
fmt.Println(slc3) // [7, 8, 9]
```

Можемо також отримати певний елемент:
```golang
slc := [][]int{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
}
fmt.Println(slc[0][1]) // 2
fmt.Println(slc[1][1]) // 5
fmt.Println(slc[2][1]) // 8
```

Для ітерації по двовимірному слайсу:
```golang
slc := [][]int{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
}
for i := 0; i < len(slc); i++ { // індекс для двовимірного слайса
    for j := 0; j < len(slc[i]); i++ { // індекс для елемента двовимірного слайса
        fmt.Println(slc[i][j])
    }
    fmt.Println() // виводимо нову строку після того, як вивели всі елементи одного слайса
}
```
Результатом має бути:
```
123
456
789
```
